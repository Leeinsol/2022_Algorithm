# -*- coding: utf-8 -*-
"""3. circularDoublyLL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g3sQWRhWeRYG93QDb0Nx7wGPAXFL2kP-
"""

# 알고리즘: 원형 양방향 연결 리스트
class BidirectNode:
    def __init__(self, x, prevNode:'BidirectNode', nextNode:'BidirectNode'):
        self.item = x
        self.prev = prevNode
        self.next = nextNode
        
class CircularDoublyLinkedList:
	def __init__(self):
		self.__head = BidirectNode("dummy", None, None)
		self.__head.prev = self.__head		# 자기 자신을 가리킴
		self.__head.next = self.__head
		self.__numItems = 0
 
 # 원소 삽입
	def insert(self, i:int, newItem) -> None:
		if (i >= 0 and i <= self.__numItems):
			prev = self.getNode(i - 1)
			newNode = BidirectNode(newItem, prev, prev.next)
			newNode.next.prev = newNode
			prev.next = newNode
			self.__numItems += 1
		else:
			print("index", i, ": out of bound in insert()") # 필요 시 에러 처리

	# 맨 뒤에 원소 삽입
	def append(self, newItem) -> None:
		prev = self.__head.prev
		newNode = BidirectNode(newItem, prev, self.__head)
		prev.next = newNode
		self.__head.prev = newNode
		self.__numItems += 1

	# 원소 삭제
	def pop(self, *args):
		# 가변 파라미터. 인자가 없거나 -1이면 마지막 원소로 처리하기 위함. 파이썬 리스트 규칙 만족
		if self.isEmpty():
			return None
		# 인덱스 i 결정
		if len(args) != 0: # pop(k)과 같이 인자가 있으면 i = k 할당
			i = args[0]
		if len(args) == 0 or i == -1:# pop()에 인자가 없거나 pop(-1)이면 i에 맨 끝 인덱스 할당
			i = self.__numItems - 1
		# i번 원소 삭제
		if (i >= 0 and i <= self.__numItems - 1):
			curr = self.getNode(i)
			retItem = curr.item
			curr.prev.next = curr.next
			curr.next.prev = curr.prev
			self.__numItems -= 1
			return retItem
		else:
			return None
 
	# 원소 x 삭제
	def remove(self, x):
		curr = self.__findNode(x)
		if curr != None:
			curr.prev.next = curr.next
			curr.next.prev = curr.prev
			self.__numItems -= 1
			return x
		else:
			return None

	# i번째 원소 알려줌
	def get(self, *args):
		# 가변 파라미터. 인자가 없거나 -1이면 마지막 원소로 처리하기 위함. 파이썬 리스트 규칙 만족
		if self.isEmpty(): return None
		# 인덱스 i 결정
		if len(args) != 0:   # pop(k)과 같이 인자가 있으면 i = k 할당
			i = args[0]
		if len(args) == 0 or i == -1:# pop()에 인자가 없거나 pop(-1)이면 i에 맨 끝 인덱스 할당
			i = self.__numItems - 1
		# i번 원소 리턴
		if (i >= 0 and i <= self.__numItems - 1):
			return self.getNode(i).item
		else:
			return None
 
	# x가 몇 번 원소인지 알려줌
	def index(self, x) -> int:
		cnt = 0
		for element in self:
			if element == x:
				return cnt
			cnt += 1
		return -12345

	# 리스트가 비었는지 알려줌
	def isEmpty(self) -> bool:
		return self.__numItems == 0
 
	# 리스트의 크기
	def size(self) -> int:
		return self.__numItems

	# 리스트를 비움
	def clear(self):
		self.__head = BidirectNode("dummy", None, None)
		self.__head.prev = self.__head
		self.__head.next = self.__head
		self.__numItems = 0
 
	# 리스트의 총 원소 수 
	def count(self, x) -> int:
		cnt = 0
		for element in self:
			if element == x:
					cnt += 1
		return cnt

	# 리스트에 나열할 수 있는 객체 a를 풀어서 추가
	def extend(self, a): # a는 순회 가능한 모든 객체
		for element in a:
			self.append(element)

	# 리스트를 복사해서 새 연결 리스트를 리턴
	def copy(self) -> 'CircularDoublyLinkedList':
		a = CircularDoublyLinkedList()
		for element in self:
			a.append(element)
		return a
 
	# 연결 리스트의 순서를 역으로 뒤집음
	def reverse(self) -> None:
		prev = self.__head; curr = prev.next; next = curr.next
		self.__head.next = prev.prev; self.__head.prev = curr
		for i in range(self.__numItems):
			curr.next = prev; curr.prev = next
			prev = curr; curr = next; next = next.next
 
	# 정렬
	def sort(self) -> None:
		a = []
		for element in self:
			a.append(element)
		a.sort()
		self.clear()
		for element in a:
			self.append(element)

	# 노드 찾기
	def __findNode(self, x) -> BidirectNode:
		curr = self.__head.next  # 0번 노드
		while curr != self.__head:
 
			if curr.item == x:
				return curr
			else:
				curr = curr.next
		return None

	# i번 노드 알려줌
	def getNode(self, i:int) -> BidirectNode:
		curr = self.__head  # 더미 헤드, index: -1
		for index in range(i + 1):
			curr = curr.next
		return curr
    
	# 리스트 출력
	def printList(self) -> None:
		for element in self:
			print(element, end = ' ')
		print()
	
	# 리스트 추가
	def add(self,x)-> None:
		self.append(x)
		self.sort()
 
	def __iter__(self):  # generating iterator and return
		return CircularDoublyLinkedListIterator(self)
 
class CircularDoublyLinkedListIterator:
	def __init__(self, alist):
		self.__head = alist.getNode(-1)  		# 더미 헤드
		self.iterPosition = self.__head.next  	# 0번 노드
	def __next__(self):
		if self.iterPosition == self.__head: 	# 순환 끝
			raise StopIteration
		else: # 현재 원소를 리턴하면서 다음 원소로 이동
			item = self.iterPosition.item
			self.iterPosition = self.iterPosition.next
			return item

list = CircularDoublyLinkedList()
list.append(30); 
list.insert(0, 20)
list.printList()

a = [4, 3, 3, 2, 1]
list.extend(a)
list.printList()

list.reverse()
list.printList()

list.pop(0)
list.printList()

list.add(5)
list.printList()