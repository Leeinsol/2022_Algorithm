# -*- coding: utf-8 -*-
"""2. circularLinkedList.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14qVwHOv4Rlc113trAjQZDYJnlZ1I0TUH
"""

# 알고리즘: 원형 연결리스트
class ListNode:
	def __init__(self, newItem, nextNode:'ListNode'):		# 초기화
		self.item = newItem
		self.next = nextNode

class CircularLinkedList:
	def __init__(self):		# 초기화
		self.__tail = ListNode("dummy", None)
		self.__tail.next = self.__tail
		self.__numItems = 0

	# 연결 리스트에 원소 삽입하기
	def insert(self, i:int, newItem) -> None:
		if (i >= 0 and i <= self.__numItems):
			prev = self.getNode(i - 1)
			newNode = ListNode(newItem, prev.next)
			prev.next = newNode
			if i == self.__numItems:
				self.__tail = newNode
			self.__numItems += 1	# 총 원소 개수 증가
		else:
			print("index", i, ": out of bound in insert()") # 필요 시 에러 처리

	# 맨 뒤에 원소를 추가
	def append(self, newItem) -> None:
		newNode = ListNode(newItem, self.__tail.next)
		self.__tail.next = newNode
		self.__tail = newNode
		self.__numItems += 1

	# 연결 리스트의 원소 삭제하기
	def pop(self, *args):
		# 가변 파라미터. 인자가 없거나 -1이면 마지막 원소로 처리하기 위함. 파이썬 리스트 규칙 만족
		if self.isEmpty():
			return None
		# 인덱스 i 결정
		if len(args) != 0: # pop(k)과 같이 인자가 있으면 i = k 할당
			i = args[0]
		if len(args) == 0 or i == -1:# pop()에 인자가 없거나 pop(-1)이면 i에 맨 끝 인덱스 할당
			i = self.__numItems - 1
		# i번 원소 삭제
		if (i >= 0 and i <= self.__numItems - 1):
			prev = self.getNode(i - 1)
			retItem = prev.next.item
			prev.next = prev.next.next
			if i == self.__numItems - 1:	# 마지막 원소
				self.__tail = prev		  
			self.__numItems -= 1
			return retItem
		else:
			return None

	# 연결 리스트의 원소 x 삭제하기
	def remove(self, x):
		(prev, curr) = self.__findNode(x)
		if curr != None:
			prev.next = curr.next
			if curr == self.__tail:	 
				self.__tail = prev	  
			self.__numItems -= 1
			return x
		else:
			return None

	# 연결 리스트의 i번 원소 알려주기
	def get(self, *args):
	# 가변 파라미터. 인자가 없거나 -1이면 마지막 원소로 처리하기 위함. 파이썬 리스트 규칙 만족
		if self.isEmpty():
			return None
		# 인덱스 i 결정
		if len(args) != 0: # pop(k)과 같이 인자가 있으면 i = k 할당
			i = args[0]
		if len(args) == 0 or i == -1:# pop()에 인자가 없거나 pop(-1)이면 i에 맨 끝 인덱스 할당
			i = self.__numItems - 1
		# i번 원소 리턴
		if (i >= 0 and i <= self.__numItems - 1):	# 인덱스가 존재할 때
			return self.getNode(i).item
		else:
			return None

	# x가 연결 리스트의 몇 번 원소인지 알려주기
	def index(self, x) -> int:
		cnt = 0
		for element in self:
			if element == x:
				return cnt
			cnt += 1
		return -12345

	# 리스트가 비었는지 알려주기
	def isEmpty(self) -> bool:
		return self.__numItems == 0

	# 리스트의 총 원소 수 알려주기
	def size(self) -> int:
		return self.__numItems

	# 리스트 비우기
	def clear(self):
		self.__tail = ListNode("dummy", None)
		self.__tail.next = self.__tail
		self.__numItems = 0

	# 원소 수 세기
	def count(self, x) -> int:
		cnt = 0
		for element in self:
			if element == x:
					cnt += 1
		return cnt

	# 연결 리스트에 나열할 수 있는 객체 a를 풀어서 추가
	def extend(self, a): # a는 순회 가능한 모든 객체
		for x in a:
			self.append(x)
 
 	# 연결 리스트를 복사해서 새 연결 리스트를 리턴
	def copy(self) -> b'CircularLinkedList':
		a = CircularLinkedList()
		for element in self:
			a.append(element)
		return a

	# 연결 리스트의 순서를 역으로 뒤집음
	def reverse(self) -> None:
		__head = self.__tail.next  # 더미 헤드
		prev = __head; curr = prev.next; next = curr.next
		curr.next = __head; __head.next = self.__tail; self.__tail = curr
		for i in range(self.__numItems - 1):
			prev = curr; curr = next; next = next.next
			curr.next = prev

	# 연결리스트를 정렬
	def sort(self) -> None:
		a = []
		for element in self:
			a.append(element)
		a.sort() 
		self.clear()
		for element in a:
			self.append(element)

	# 노드를 찾음
	def __findNode(self, x):
		__head = prev = self.__tail.next  # 더미 헤드
		curr = prev.next  # 0번 노드
		while curr != __head:
			if curr.item == x:
				return (prev, curr)
			else:
				prev = curr; curr = curr.next
		return (None, None)
 
	# 연결 리스트의 i번 노드 알려주기
	def getNode(self, i:int) -> ListNode:
		curr = self.__tail.next  # 더미 헤드, index: -1
		for index in range(i+1):
			curr = curr.next
		return curr

	# 연결 리스트를 출력
	def printList(self) -> None:
		for element in self:
			print(element, end = ' ')
		print()

	def __iter__(self):  # generating iterator and return
		return CircularLinkedListIterator(self)	# 순회자 객체 생성

# 순회자 클래스
class CircularLinkedListIterator:
	def __init__(self, alist):
		self.__head = alist.getNode(-1)  # 더미 헤드
		self.iterPosition = self.__head.next  # 0번 노드
	def __next__(self):
		if self.iterPosition == self.__head: # 순환 끝
			raise StopIteration
		else: # 현재 원소를 리턴하면서 다음 원소로 이동
			item = self.iterPosition.item
			self.iterPosition = self.iterPosition.next
			return item

# 코드 5-22

list = CircularLinkedList()
list.append(30)
list.insert(0, 20)
list.printList()
a = [4, 3, 3, 2, 1]
list.extend(a)
list.printList()
list.reverse()
list.pop(0)
print("count(3):", list.count(3))
print("get(2):", list.get(2))
list.printList()

# 코드 5-23